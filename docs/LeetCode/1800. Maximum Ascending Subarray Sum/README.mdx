---
title: 1800. Maximum Ascending Subarray Sum
description: You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.
keywords:
  [
    LeetCode,
    1800. Maximum Ascending Subarray Sum,
    Easy,
    Hash Table,
    String,
    Counting,
  ]
tags: [LeetCode, Easy, Hash Table, String, Counting]
---

# [{frontMatter.title}](https://leetcode.com/problems/maximum-ascending-subarray-sum/)

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import DifficultyBadge from "@site/src/components/Badges/DifficultyBadge";
import Solution from "!!raw-loader!./solution.js";
import Description from "./_Description.md";
import Examples from "./_Examples.md";

<DifficultyBadge difficulty="Easy" />

<Tabs>
  <TabItem value="description" label="題目描述" default>
    <details open>
      <summary>Description</summary>
        <Description />
        <Examples />
    </details> 
  </TabItem>

  <TabItem value="solution" label="解答">
   ## Solution
    <CodeBlock language="js">{Solution}</CodeBlock>
  </TabItem>
</Tabs>

## 解題思路

直接遍歷陣列暴力比較 `i` 有沒有比 `i - 1` 大，有的話就加上 `i`，如果碰壁的話就看之前累加的跟現在累加的哪個比較大並紀錄大的那個，並把碰壁的 `nums[i]` 當成新的起點繼續遍歷陣列

## 心得

一開始差了「把碰壁的 `nums[i]` 當成新的起點」所以邏輯有誤，解題完之後看整體發現其實比想像中的簡單。
