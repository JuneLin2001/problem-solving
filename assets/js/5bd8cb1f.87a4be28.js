"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7336],{7474:e=>{e.exports=JSON.parse('{"tag":{"label":"LeetCode","permalink":"/problem-solving/tags/leet-code","allTagsPath":"/problem-solving/tags","count":34,"items":[{"id":"LeetCode/Container With Most Water/README","title":"11. Container With Most Water","description":"You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container.","permalink":"/problem-solving/LeetCode/Container With Most Water/"},{"id":"LeetCode/Check If N and Its Double Exist/README","title":"1346. Check If N and Its Double Exist","description":"Given an array arr of integers, check if there exist two indices i and j such that","permalink":"/problem-solving/LeetCode/Check If N and Its Double Exist/"},{"id":"LeetCode/Water Bottles/README","title":"1518. Water Bottles","description":"There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.","permalink":"/problem-solving/LeetCode/Water Bottles/"},{"id":"LeetCode/Count Odd Numbers in an Interval Range/README","title":"1523. Count Odd Numbers in an Interval Range","description":"Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).","permalink":"/problem-solving/LeetCode/Count Odd Numbers in an Interval Range/"},{"id":"LeetCode/Minimum Number of Increments on Subarrays to Form a Target Array/README","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array","description":"You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros. In one operation you can choose any subarray from initial and increment each value by one. Return the minimum number of operations to form a target array from initial. The test cases are generated so that the answer fits in a 32-bit integer.","permalink":"/problem-solving/LeetCode/Minimum Number of Increments on Subarrays to Form a Target Array/"},{"id":"LeetCode/Calculate Money in Leetcode Bank/README","title":"1716. Calculate Money in Leetcode Bank","description":"Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.","permalink":"/problem-solving/LeetCode/Calculate Money in Leetcode Bank/"},{"id":"LeetCode/Check if Array Is Sorted and Rotated/README","title":"1752. Check if Array Is Sorted and Rotated","description":"Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.","permalink":"/problem-solving/LeetCode/Check if Array Is Sorted and Rotated/"},{"id":"LeetCode/Check if One String Swap Can Make Strings Equal/README","title":"1790. Check if One String Swap Can Make Strings Equal","description":"You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.","permalink":"/problem-solving/LeetCode/Check if One String Swap Can Make Strings Equal/"},{"id":"LeetCode/Maximum Ascending Subarray Sum/README","title":"1800. Maximum Ascending Subarray Sum","description":"You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.","permalink":"/problem-solving/LeetCode/Maximum Ascending Subarray Sum/"},{"id":"LeetCode/Final Value of Variable After Performing Operations/README","title":"2011. Final Value of Variable After Performing Operations","description":"There is a programming language with only four operations and one variable X. Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.","permalink":"/problem-solving/LeetCode/Final Value of Variable After Performing Operations/"},{"id":"LeetCode/Simple Bank System/README","title":"2043. Simple Bank System","description":"You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i].","permalink":"/problem-solving/LeetCode/Simple Bank System/"},{"id":"LeetCode/Next Greater Numerically Balanced Number/README","title":"2048. Next Greater Numerically Balanced Number","description":"An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x. Given an integer n, return the smallest numerically balanced number strictly greater than n.","permalink":"/problem-solving/LeetCode/Next Greater Numerically Balanced Number/"},{"id":"LeetCode/Minimum Size Subarray Sum/README","title":"209. Minimum Size Subarray Sum","description":"Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.","permalink":"/problem-solving/LeetCode/Minimum Size Subarray Sum/"},{"id":"LeetCode/Find Triangular Sum of an Array/README","title":"2221. Find Triangular Sum of an Array","description":"You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive).","permalink":"/problem-solving/LeetCode/Find Triangular Sum of an Array/"},{"id":"LeetCode/Add Two Integers/README","title":"2235. Add Two Integers","description":"You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.","permalink":"/problem-solving/LeetCode/Add Two Integers/"},{"id":"LeetCode/Successful Pairs of Spells and Potions/README","title":"2300. Successful Pairs of Spells and Potions","description":"You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.","permalink":"/problem-solving/LeetCode/Successful Pairs of Spells and Potions/"},{"id":"LeetCode/Count Number of Bad Pairs/README","title":"2364. Count Number of Bad Pairs","description":"You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i]. Return the total number of bad pairs in nums.","permalink":"/problem-solving/LeetCode/Count Number of Bad Pairs/"},{"id":"LeetCode/Count Total Number of Colored Cells/README","title":"2579. Count Total Number of Colored Cells","description":"There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes","permalink":"/problem-solving/LeetCode/Count Total Number of Colored Cells/"},{"id":"LeetCode/Maximum Area of Longest Diagonal Rectangle/README","title":"3000. Maximum Area of Longest Diagonal Rectangle","description":"You are given a 2D 0-indexed integer array dimensions.","permalink":"/problem-solving/LeetCode/Maximum Area of Longest Diagonal Rectangle/"},{"id":"LeetCode/Water Bottles II/README","title":"3100. Water Bottles II","description":"You are given two integers numBottles and numExchange. numBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations","permalink":"/problem-solving/LeetCode/Water Bottles II/"},{"id":"LeetCode/Longest Strictly Increasing or Strictly Decreasing Subarray/README","title":"3105. Longest Strictly Increasing or Strictly Decreasing Subarray","description":"You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing .","permalink":"/problem-solving/LeetCode/Longest Strictly Increasing or Strictly Decreasing Subarray/"},{"id":"LeetCode/Special Array I/README","title":"3151. Special Array I","description":"You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing .","permalink":"/problem-solving/LeetCode/Special Array I/"},{"id":"LeetCode/The Two Sneaky Numbers of Digitville/README","title":"3289. The Two Sneaky Numbers of Digitville","description":"In the town of Digitville, there was a list of numbers called nums containing integers from 0 to n - 1. Each number was supposed to appear exactly once in the list, however, two mischievous numbers sneaked in an additional time, making the list longer than usual. As the town detective, your task is to find these two sneaky numbers. Return an array of size two containing the two numbers (in any order), so peace can return to Digitville.","permalink":"/problem-solving/LeetCode/The Two Sneaky Numbers of Digitville/"},{"id":"LeetCode/Adjacent Increasing Subarrays Detection I/README","title":"3349. Adjacent Increasing Subarrays Detection I","description":"Given an array nums of n integers and an integer k, determine whether there exist two adjacent subarrays of length k such that both subarrays are strictly increasing. Specifically, check if there are two subarrays starting at indices a and b (a < b)","permalink":"/problem-solving/LeetCode/Adjacent Increasing Subarrays Detection I/"},{"id":"LeetCode/Adjacent Increasing Subarrays Detection II/README","title":"3350. Adjacent Increasing Subarrays Detection II","description":"Given an array nums of n integers, your task is to find the maximum value of k for which there exist two adjacent subarrays of length k each, such that both subarrays are strictly increasing. Specifically, check if there are two subarrays of length k starting at indices a and b (a < b)","permalink":"/problem-solving/LeetCode/Adjacent Increasing Subarrays Detection II/"},{"id":"LeetCode/Make Array Elements Equal to Zero/README","title":"3354. Make Array Elements Equal to Zero","description":"You are given an integer array nums. Start by selecting a starting position curr such that nums[curr] == 0, and choose a movement direction of either left or right.","permalink":"/problem-solving/LeetCode/Make Array Elements Equal to Zero/"},{"id":"LeetCode/Smallest Number With All Set Bits/README","title":"3370. Smallest Number With All Set Bits","description":"You are given a positive number n. Return the smallest number x greater than or equal to n, such that the binary representation of x contains only set bits","permalink":"/problem-solving/LeetCode/Smallest Number With All Set Bits/"},{"id":"LeetCode/Maximum Number of Distinct Elements After Operations/README","title":"3397. Maximum Number of Distinct Elements After Operations","description":"You are given an integer array nums and an integer k.You are allowed to perform the following operation on each element of the array at most once:Add an integer in the range [-k, k] to the element.Return the maximum possible number of distinct elements in nums after performing the operations.","permalink":"/problem-solving/LeetCode/Maximum Number of Distinct Elements After Operations/"},{"id":"LeetCode/Check If Digits Are Equal in String After Operations I/README","title":"3461. Check If Digits Are Equal in String After Operations I","description":"You are given a string s consisting of digits. Perform the following operation repeatedly until the string has exactly two digits:For each pair of consecutive digits in s, starting from the first digit, calculate a new digit as the sum of the two digits modulo 10. Replace s with the sequence of newly calculated digits, maintaining the order in which they are computed. Return true if the final two digits in s are the same; otherwise, return false.","permalink":"/problem-solving/LeetCode/Check If Digits Are Equal in String After Operations I/"},{"id":"LeetCode/Intersection of Two Arrays/README","title":"349. Intersection of Two Arrays","description":"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.","permalink":"/problem-solving/LeetCode/Intersection of Two Arrays/"},{"id":"LeetCode/Ransom Note/README","title":"383. Ransom Note","description":"Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.","permalink":"/problem-solving/LeetCode/Ransom Note/"},{"id":"LeetCode/Is Subsequence/README","title":"392. Is Subsequence","description":"Given two strings s and t, return true if s is a subsequence of t, or false otherwise.","permalink":"/problem-solving/LeetCode/Is Subsequence/"},{"id":"LeetCode/Fibonacci Number/README","title":"509. Fibonacci Number","description":"The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1.","permalink":"/problem-solving/LeetCode/Fibonacci Number/"},{"id":"LeetCode/Binary Search/README","title":"704. Binary Search","description":"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.","permalink":"/problem-solving/LeetCode/Binary Search/"}],"unlisted":false}}')}}]);